/*
***Math*** (*)
    Description:
        找出 [1, n] 的所有整數中 k: 0<=k<=9 出現的次數。 (22 算兩個 2)
    Solution:
        先把 0 撇開，然後找出以下規律:
            1~10    在個位出現數字 k 共: 1    次
            1~100   在十位出現數字 k 共: 10   次
            1~1000  在百位出現數字 k 共: 100  次
        可以看出，1~10^i 中，在 10^(i-1) 位出現數字 k 共 10^(i-1) 次。
        舉例 n = 2593, k = 5 為例:
            首先 2593 = 259*10 + 3，共 259 個 "10"，因此 ans += 1*259，又
            3 < k=5，所以不包含 k。(個)
            再來，2593 = 25*100 + 93，共 25 個 "100"，因此 ans += 10*25，
            又 9 > k=5，代表最大的十位數字大於 k，因此 ans += 10。(十)
            接著 2593 = 2*1000 + 593，共 2 個 "1000"，因此 ans += 2*100，又
            5 = 5，代表最大的百位數字剛好是 k，因此 ans += 93+1 (500~593)。(百)
            最後 2593 = 0*10000 + 2593，可以看出 2 < 5，到此計算結束。
        至於 k = 0 要注意的就是: "最高位不可有 0"，因此不可以有上述的最後一步，程式
        到該處要提早結束。
    O(log n)
*/
#include <bits/stdc++.h>
using namespace std;

int main() {
    int64_t n, k;
    while(cin >> n >> k) {
        int64_t cnt = 0;
        // b: 目前要做哪一位數的計數 (b = 10^i)
        for(int64_t b=1; b<=n; b*=10) {
            int64_t high = n/b/10; // 共有 "high 個 10b" (因為要數 10^i 必須看 10^(i+1)) 
            if(!k) 
                if(--high < 0) break; // 提早結束
            cnt += high * b;
            int64_t low = (n/b) % 10; // 相對於目前 high 的餘數的最高位數 (10^b)
            if(k < low) cnt += b; // 超過 k，可以包含
            else if(k == low) cnt += n%b + 1; // 恰 k，再向下取
        }
        cout << cnt << '\n';
    }
    return 0;
}