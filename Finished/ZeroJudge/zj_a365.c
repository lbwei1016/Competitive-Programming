/*
***位元 DP***
    Solution:
        若狀態數不多且不易以遞迴、迴圈窮舉，則手動列舉，不需要想太多
    O(n)
*/
#include <stdio.h>

int main() {
    int dp[1<<12] = {}; //0 or 1
    int i, j, state;

    //24種取棋法: 包括一次取一或取二
    int lk[24] = {1<<0,1<<1,1<<2,1<<3,1<<4,1<<5,1<<6,
                1<<7,1<<8,1<<9,1<<10,1<<11,1<<0|1<<3,
                1<<1|1<<4,1<<2|1<<3,1<<3|1<<4,1<<4|1<<5,
                1<<3|1<<7,1<<4|1<<8,1<<6|1<<7,1<<7|1<<8,
                1<<8|1<<9,1<<7|1<<10,1<<8|1<<11};
                
    dp[0] = 1; //若空則算先手贏
    //題目共 1 << 12 種狀態
    for(i = 0; i < 4096; i++) {
        for(j = 0; j < 24; j++) {
            //當題目 i 包含取法 lk[j]
            if((i&lk[j]) == lk[j]) {
                //每取一次贏家交換，但若先手本來就可以獲勝，則狀態不變(因為先手可以選擇)
                dp[i] |= !dp[i-lk[j]];
            }
        }
    }
    int n;
    char s[50];
    scanf("%d", &n);
    while(n--) {
        scanf("%s", s);
        int state = 0;
        for(i = 0; s[i]; i++)
            state += (s[i]-'0')<<(11-i);
        printf("%d", dp[state]);
    }
    printf("\n");
    return 0;
}